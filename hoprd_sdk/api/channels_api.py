# coding: utf-8

"""
    HOPRd Rest API v3

    This Rest API enables developers to interact with a hoprd node programatically.  # noqa: E501

    OpenAPI spec version: 3.0.0
    Contact: tech@hoprnet.org
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from hoprd_sdk.api_client import ApiClient


class ChannelsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def channels_aggregate_tickets(self, channelid, **kwargs):  # noqa: E501
        """channels_aggregate_tickets  # noqa: E501

        Takes all acknowledged and winning tickets (if any) from the given channel and aggregates them into a single ticket. Requires cooperation of the ticket issuer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_aggregate_tickets(channelid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channelid: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_aggregate_tickets_with_http_info(channelid, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_aggregate_tickets_with_http_info(channelid, **kwargs)  # noqa: E501
            return data

    def channels_aggregate_tickets_with_http_info(self, channelid, **kwargs):  # noqa: E501
        """channels_aggregate_tickets  # noqa: E501

        Takes all acknowledged and winning tickets (if any) from the given channel and aggregates them into a single ticket. Requires cooperation of the ticket issuer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_aggregate_tickets_with_http_info(channelid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channelid: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channelid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_aggregate_tickets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channelid' is set
        if ('channelid' not in params or
                params['channelid'] is None):
            raise ValueError("Missing the required parameter `channelid` when calling `channels_aggregate_tickets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channelid' in params:
            path_params['channelid'] = params['channelid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['keyScheme', 'passwordScheme']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelid}/tickets/aggregate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_close_channel(self, channelid, **kwargs):  # noqa: E501
        """channels_close_channel  # noqa: E501

        Close a opened channel between this node and other node. Once you've initiated channel closure, you have to wait for a specified closure time, it will show you a closure initiation message with cool-off time you need to wait.   Then you will need to send the same command again to finalize closure. This is a cool down period to give the other party in the channel sufficient time to redeem their tickets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_close_channel(channelid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channelid: (required)
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_close_channel_with_http_info(channelid, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_close_channel_with_http_info(channelid, **kwargs)  # noqa: E501
            return data

    def channels_close_channel_with_http_info(self, channelid, **kwargs):  # noqa: E501
        """channels_close_channel  # noqa: E501

        Close a opened channel between this node and other node. Once you've initiated channel closure, you have to wait for a specified closure time, it will show you a closure initiation message with cool-off time you need to wait.   Then you will need to send the same command again to finalize closure. This is a cool down period to give the other party in the channel sufficient time to redeem their tickets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_close_channel_with_http_info(channelid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channelid: (required)
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channelid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_close_channel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channelid' is set
        if ('channelid' not in params or
                params['channelid'] is None):
            raise ValueError("Missing the required parameter `channelid` when calling `channels_close_channel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channelid' in params:
            path_params['channelid'] = params['channelid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['keyScheme', 'passwordScheme']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelid}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_fund_channel(self, channelid, **kwargs):  # noqa: E501
        """channels_fund_channel  # noqa: E501

        Funds an existing channel with the given amount. The channel must be in state OPEN  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_fund_channel(channelid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channelid: (required)
        :param ChannelidFundBody body:
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_fund_channel_with_http_info(channelid, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_fund_channel_with_http_info(channelid, **kwargs)  # noqa: E501
            return data

    def channels_fund_channel_with_http_info(self, channelid, **kwargs):  # noqa: E501
        """channels_fund_channel  # noqa: E501

        Funds an existing channel with the given amount. The channel must be in state OPEN  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_fund_channel_with_http_info(channelid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channelid: (required)
        :param ChannelidFundBody body:
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channelid', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_fund_channel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channelid' is set
        if ('channelid' not in params or
                params['channelid'] is None):
            raise ValueError("Missing the required parameter `channelid` when calling `channels_fund_channel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channelid' in params:
            path_params['channelid'] = params['channelid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['keyScheme', 'passwordScheme']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelid}/fund', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_get_channel(self, channelid, **kwargs):  # noqa: E501
        """channels_get_channel  # noqa: E501

        Returns information about the channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_get_channel(channelid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ChannelId channelid: (required)
        :return: ChannelTopology
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_get_channel_with_http_info(channelid, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_get_channel_with_http_info(channelid, **kwargs)  # noqa: E501
            return data

    def channels_get_channel_with_http_info(self, channelid, **kwargs):  # noqa: E501
        """channels_get_channel  # noqa: E501

        Returns information about the channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_get_channel_with_http_info(channelid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ChannelId channelid: (required)
        :return: ChannelTopology
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channelid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_get_channel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channelid' is set
        if ('channelid' not in params or
                params['channelid'] is None):
            raise ValueError("Missing the required parameter `channelid` when calling `channels_get_channel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channelid' in params:
            path_params['channelid'] = params['channelid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['keyScheme', 'passwordScheme']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelid}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ChannelTopology',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_get_channels(self, **kwargs):  # noqa: E501
        """channels_get_channels  # noqa: E501

        Lists all active channels between this node and other nodes on the Hopr network. By default response will contain all incomming and outgoing channels that are either open, waiting to be opened, or waiting to be closed. If you also want to receive past channels that were closed, you can pass `includingClosed` in the request url query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_get_channels(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str including_closed: When includingClosed is passed the response will include closed channels which are ommited by default.
        :param str full_topology: Get the full payment channel graph indexed by the node.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_get_channels_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.channels_get_channels_with_http_info(**kwargs)  # noqa: E501
            return data

    def channels_get_channels_with_http_info(self, **kwargs):  # noqa: E501
        """channels_get_channels  # noqa: E501

        Lists all active channels between this node and other nodes on the Hopr network. By default response will contain all incomming and outgoing channels that are either open, waiting to be opened, or waiting to be closed. If you also want to receive past channels that were closed, you can pass `includingClosed` in the request url query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_get_channels_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str including_closed: When includingClosed is passed the response will include closed channels which are ommited by default.
        :param str full_topology: Get the full payment channel graph indexed by the node.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['including_closed', 'full_topology']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_get_channels" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'including_closed' in params:
            query_params.append(('includingClosed', params['including_closed']))  # noqa: E501
        if 'full_topology' in params:
            query_params.append(('fullTopology', params['full_topology']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['keyScheme', 'passwordScheme']  # noqa: E501

        return self.api_client.call_api(
            '/channels/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_get_tickets(self, channelid, **kwargs):  # noqa: E501
        """channels_get_tickets  # noqa: E501

        Get tickets earned by relaying data packets by your node for the particular channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_get_tickets(channelid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channelid: (required)
        :return: list[Ticket]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_get_tickets_with_http_info(channelid, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_get_tickets_with_http_info(channelid, **kwargs)  # noqa: E501
            return data

    def channels_get_tickets_with_http_info(self, channelid, **kwargs):  # noqa: E501
        """channels_get_tickets  # noqa: E501

        Get tickets earned by relaying data packets by your node for the particular channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_get_tickets_with_http_info(channelid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channelid: (required)
        :return: list[Ticket]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channelid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_get_tickets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channelid' is set
        if ('channelid' not in params or
                params['channelid'] is None):
            raise ValueError("Missing the required parameter `channelid` when calling `channels_get_tickets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channelid' in params:
            path_params['channelid'] = params['channelid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['keyScheme', 'passwordScheme']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelid}/tickets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Ticket]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_open_channel(self, **kwargs):  # noqa: E501
        """channels_open_channel  # noqa: E501

        Opens a payment channel between this node and the counter party provided. This channel can be used to send messages between two nodes using other nodes on the network to relay the messages. Each message will deduce its cost from the funded amount to pay other nodes for relaying your messages. Opening a channel can take a little bit of time, because it requires some block confirmations on the blockchain.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_open_channel(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ChannelsBody body:
        :return: InlineResponse2011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_open_channel_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.channels_open_channel_with_http_info(**kwargs)  # noqa: E501
            return data

    def channels_open_channel_with_http_info(self, **kwargs):  # noqa: E501
        """channels_open_channel  # noqa: E501

        Opens a payment channel between this node and the counter party provided. This channel can be used to send messages between two nodes using other nodes on the network to relay the messages. Each message will deduce its cost from the funded amount to pay other nodes for relaying your messages. Opening a channel can take a little bit of time, because it requires some block confirmations on the blockchain.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_open_channel_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ChannelsBody body:
        :return: InlineResponse2011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_open_channel" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['keyScheme', 'passwordScheme']  # noqa: E501

        return self.api_client.call_api(
            '/channels/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_redeem_tickets(self, channelid, **kwargs):  # noqa: E501
        """channels_redeem_tickets  # noqa: E501

        Redeems your tickets for this channel. Redeeming will change your tickets into Hopr tokens if they are winning ones. You can check how much tickets given channel has by calling /channels/{channelid}/tickets endpoint. Do this before channel is closed as neglected tickets are no longer valid for redeeming.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_redeem_tickets(channelid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channelid: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_redeem_tickets_with_http_info(channelid, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_redeem_tickets_with_http_info(channelid, **kwargs)  # noqa: E501
            return data

    def channels_redeem_tickets_with_http_info(self, channelid, **kwargs):  # noqa: E501
        """channels_redeem_tickets  # noqa: E501

        Redeems your tickets for this channel. Redeeming will change your tickets into Hopr tokens if they are winning ones. You can check how much tickets given channel has by calling /channels/{channelid}/tickets endpoint. Do this before channel is closed as neglected tickets are no longer valid for redeeming.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_redeem_tickets_with_http_info(channelid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str channelid: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['channelid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_redeem_tickets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'channelid' is set
        if ('channelid' not in params or
                params['channelid'] is None):
            raise ValueError("Missing the required parameter `channelid` when calling `channels_redeem_tickets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'channelid' in params:
            path_params['channelid'] = params['channelid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['keyScheme', 'passwordScheme']  # noqa: E501

        return self.api_client.call_api(
            '/channels/{channelid}/tickets/redeem', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
